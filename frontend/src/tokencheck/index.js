import WalletConnect from "@walletconnect/web3-provider";
import Web3Modal from "web3modal";
import {ethers} from "ethers";

/**
 * Interface for storage backends.
 * Provides two methods: set and get.
 */
export class StorageBackend {
    set(key, value) {
        throw new Error('Not implemented');
    }
    
    get(key) {
        throw new Error('Not implemented');
    }
}

/**
 * Basic implementation of storage backend interface based on LocalStorage
 */
export class LocalStorageBackend extends StorageBackend {
    
    set(key, value) {
        localStorage.setItem(key, JSON.stringify(value));
    }
    
    get(key) {
        return JSON.parse(localStorage.getItem(key));
    }
}

class ApiBase {
    constructor(baseUrl, tokenGetter) {
        this.baseUrl = baseUrl;
        this.tokenGetter = tokenGetter;
    }

    async get(path, params) {
        let url = new URL(this.baseUrl + path);
        if (params) {
            Object.keys(params).forEach(key => url.searchParams.append(key, params[key]));
        }
        return await this.preHandleResponse(
            fetch(url, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json',
                        'Authorization': this.tokenGetter()
                    }
                }
        ));
    }

    async preHandleResponse(request) {
        let r;
        try {
            r = await request;
        } catch (e) {
            throw {
                message: "Internal Server Error",
            }
        }
        if (!r.ok) {
            const c = await r.json();
            if (c.detail) {
                const d = c.detail[0];
                const loc = d.loc ? d.loc.join('.') + ": " : "";
                if (d.msg) {
                    throw {
                        message: loc + d.msg,
                    }
                }
            }
            throw c;
        }
        return r;
    }

    async post(path, data, params) {
        let url = new URL(this.baseUrl + path);
        if (params) {
            Object.keys(params).forEach(key => url.searchParams.append(key, params[key]));
        }

        return await this.preHandleResponse(
            fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                    'Authorization': this.tokenGetter()
                },
                body: JSON.stringify(data)
            })
        )
    }
}

/**
 * API wrapper
 */
export class TokenCheck extends ApiBase {

    constructor(url, storageBackend) {
        const storage = new storageBackend();

        super(url, () => storage.get('token'));
        this._backendURL = url;
        this._storage = storage;
        this._isAuthenticated = false;
    }

    /**
     * Initialize the API. If jwt token exists, it will attempt to authenticate with it.
     * @returns {Promise<boolean>}
     */
    async init() {
        if (this._storage.get('token')) {
            const user = await this._getMe();

            if (user) {
                this._storage.set('user', user);
                this._isAuthenticated = true;
                return true;
            }
        }
        return false;
    }

    /**
     * Open a modal window to authenticate with wallet.
     * Will sign a message generated by the backend and send it back to verify.
     * In case of successful authentication, it will store the jwt token in the storage backend.
     * @returns {Promise<*>}
     */
    async connectWallet() {
        const providerOptions = {
            themeMode: "dark",
            walletconnect: {
                package: WalletConnect,
                options: {
                    rpc: {
                        1: "https://rpc.ankr.com/eth",
                        137: "https://rpc.ankr.com/polygon",
                        56: "https://rpc.ankr.com/bsc",
                    },
                    bridge: "https://bridge.walletconnect.org",
                    qrcode: false
                }
            }
        };
        const web3Modal = new Web3Modal({
            providerOptions
        });

        const provider = await web3Modal.connect();
        const library = new ethers.providers.Web3Provider(provider);
        const wallet_address = (await library.listAccounts())[0];

        const messageToSign = await this.getMessageToSign(wallet_address);

        const signedMessage = await library.send("personal_sign", [messageToSign, wallet_address]);

        if (!signedMessage) {
            alert('Invalid signature')
            return
        }

        let verificationRequest = {
            'signature': signedMessage,
            'message': messageToSign,
            'wallet_address': wallet_address,
        }

        const token = await this.verifySignature(verificationRequest);
        this._storage.set('token', token);

        const user = await this._getMe();
        this._storage.set('user', user);

        this._isAuthenticated = true;
        return user;
    }

    /**
     * Whether user is authenticated or not
     * @returns {boolean}
     */
    isAuthenticated() {
        return this._isAuthenticated;
    }

    /**
     * Download a CSV file with submitted user profiles
     * @param context_uuid {string} UUID of the context to export data from
     */
    exportCSV(context_uuid) {
        window.open(
            this._backendURL + '/organization/export?context_uuid=' + context_uuid + '&token=' + this._storage.get('token'),
            '_blank'
        );
    }

    /**
     * Get a message to sign from the backend.
     * @param wallet_address {string} Wallet address to sign the message with
     * @returns {Promise<string|null>} Message to sign
     */
    async getMessageToSign(wallet_address) {
        let response = await this.post('/verification/message', {'wallet_address': wallet_address});
        let res = await response.json();

        if (res.error) {
            alert('Received error from server: ' + res.data)
            return null;
        }

        return res.data;
    }

    /**
     * Send signed message to backend to verify.
     * @param requestPayload {{signature: string, message: string, wallet_address: string}} Payload to send to backend
     * @returns {Promise<*|null>}
     */
    async verifySignature(requestPayload) {
        const response = await this.post('/verification/verify', requestPayload);

        // get json data from response
        const data = await response.json();

        if (data.error) {
            alert(data.message);
            return null;
        }

        return data.data;
    }

    /**
     * Get user data from storage
     * @returns {*}
     */
    getMe() {
        return this._storage.get('user');
    }

    /**
     * Get user data from backend
     * @returns {Promise<*|null>}
     * @private
     */
    async _getMe() {
        if (!localStorage.token) {
            return null;
        }

        try {
            const response = await this.get('/user/me');

            const {error, data, message} = await response.json();

            if (error) {
                alert(message);
            }

            return data;
        } catch (e) {
            console.error(e);
        }
        return null;
    }

    /**
     * Get list of contracts in organization
     * @param org_id {number} id of the organization
     * @returns {Promise<*>}
     */
    async getContracts(org_id) {
        const response = await this.get('/organization/contracts', {'org_id': org_id});

        const {error, message, data} = await response.json();

        if (error) {
            alert(message);
        }

        return data;
    }

    /**
     * Create or Update profile
     * @param data {{
     *         first_name: string,
     *         last_name: string,
     *         phone: string,
     *         email: string,
     *         address1: string,
     *         address2: string,
     *         address3: string,
     *         city: string,
     *         region: string,
     *         postal_code: string,
     *         country: string,
     *         sizes: Array
     * }} Profile data
     * @param contest_uuid {string} UUID of the contest to submit the profile to
     * @param update {boolean} Whether to update or create a new profile
     * @returns {Promise<{profile, message}|null>}
     */
    async sendContact(data, contest_uuid, update = false) {
        const url = update ? '/user/profile/update' : '/user/profile/create';
        let response = await this.post(url, data, {'context_uuid': contest_uuid});

        response = await response.json();

        if(response.error) {
            alert(response.message)
            return null;
        }
        return {profile: response.data, message: response.message};
    }

    /**
     * Get context data
     * @param context_uuid {string} UUID of the context to get data for
     * @returns {Promise<{}>} context data
     */
    async getContext(context_uuid) {
        const response = await this.get('/context/' + context_uuid);

        const {error, message, data} = await response.json();

        if (error) {
            alert(message);
        }

        return data;
    }

    /**
     * Get transaction breakdowns for organization
     * @param org_id {number} id of the organization
     * @returns {Promise<{}|null>} Transaction breakdowns
     */
    async getTxBreakdowns(org_id) {
        const response = await this.get('/organization/tx/breakdowns', {'org_id': org_id});
        const data = await response.json();
        if(data.error) {
            alert(data.message)
            return null;
        }
        return data.data;
    }

    /**
     * Get profile list for context
     * @param context_uuid {string} UUID of the context to get profiles for
     * @returns {Promise<Array<{}>|null>} Profile list
     */
    async getHolders(context_uuid) {
        const response = await this.get('/organization/holders', {'context_uuid': context_uuid});
        const data = await response.json();

        if(data.error) {
            alert(data.message)
            return null;
        }
        return data.data;
    }

    /**
     * Get profile breakdowns for organization
     * @param org_id {number} id of the organization
     * @returns {Promise<*|null>} Profile breakdowns
     */
    async getWalletBreakdowns(org_id) {
        const response = await this.get('/organization/wallet/breakdowns', {'org_id': org_id});
        const data = await response.json();

        if(data.error) {
            alert(data.message)
            return null;
        }
        return data.data;
    }

    /**
     * Get general stats for organization
     * @param org_id {number} id of the organization
     * @returns {Promise<*|null>}
     */
    async getStats(org_id) {
        const response = await this.get('/organization/stats', {'org_id': org_id});
        const data = await response.json();

        if(data.error) {
            alert(data.message)
            return null;
        }
        return data.data;
    }

    /**
     * Create new organization
     * @param payload {{name: string, admins: Array<string>, contracts: Array<number>}}
     * @returns {Promise<*|null>}
     */
    async createOrg(payload) {
        const response = await this.post('/superadmin/organization/create', payload);
        const data = await response.json();

        if(data.error) {
            alert(data.message)
            return null;
        }

        return data.data;
    }

    /**
     * Get list of organizations
     * @returns {Promise<*|null>}
     */
    async listOrgs() {
        const response = await this.get('/superadmin/organization/list');
        const data = await response.json();

        if(data.error) {
            alert(data.message)
            return null;
        }

        return data.data;
    }

    /**
     * Add admin to organization
     * @param admin {string} wallet of the admin to add
     * @param org_id {number} id of the organization
     * @returns {Promise<*|null>}
     */
    async addAdmin(admin, org_id) {
        const response = await this.post('/organization/admin/add', {address: admin}, {'org_id': org_id});
        const data = await response.json();

        if(data.error) {
            alert(data.message)
            return null;
        }

        return data.data;
    }

    /**
     * Remove admin from organization
     * @param admin {string} wallet of the admin to remove
     * @param org_id {number} id of the organization
     * @returns {Promise<*|null>}
     */
    async removeAdmin(admin, org_id) {
        const response = await this.post('/organization/admin/remove', {address: admin}, {'org_id': org_id});
        const data = await response.json();

        if(data.error) {
            alert(data.message)
            return null;
        }

        return data.data;
    }

    /**
     * Add new context to organization
     * @param payload {{
     *         address: string,
     *         chain: number,
     *         name: string,
     *         standard: number,
     *         threshold: number,
     *         token_id_whitelist: Array<number>,
     *         title: string,
     *         image: string
     * }}
     * @param org_id {number} id of the organization
     * @returns {Promise<*|null>}
     */
    async addContract(payload, org_id) {
        const response = await this.post('/organization/contract/create', payload, {'org_id': org_id});
        const data = await response.json();

        if(data.error) {
            alert(data.message)
            return null;
        }

        return data.data;
    }

    /**
     * Remove context from organization
     * @param context_uuid {string} UUID of the context to remove
     * @returns {Promise<*|null>}
     */
    async removeContext(context_uuid) {
        const response = await this.post('/organization/contract/delete', {}, {context_uuid});
        const data = await response.json();

        if(data.error) {
            alert(data.message)
            return null;
        }

        return data.data;
    }

    /**
     * Edit context
     * @param context_uuid {string} UUID of the context to edit
     * @param payload {{
     *         address: string,
     *         chain: number,
     *         name: string,
     *         standard: number,
     *         threshold: number,
     *         token_id_whitelist: Array<number>,
     *         title: string,
     *         image: string
     * }}
     * @returns {Promise<*|null>}
     */
    async editContext(context_uuid, payload) {
        const response = await this.post('/organization/context/update', payload, {context_uuid});
        const data = await response.json();

        if(data.error) {
            alert(data.message)
            return null;
        }

        return data.data;
    }

    /**
     * Get organization by id
     * @param org_id
     * @returns {Promise<*|null>}
     */
    async getOrg(org_id) {
        const response = await this.get('/superadmin/organization/' + org_id);
        const data = await response.json();

        if(data.error) {
            alert(data.message)
            return null;
        }

        return data.data;
    }

    /**
     * disable organization
     * @param orgId {number} id of the organization
     * @returns {Promise<*|null>}
     */
    async disableOrg(orgId) {
        const response = this.post('/superadmin/organization/' + orgId + '/disable');
        const data = await response.json();

        if(data.error) {
            alert(data.message)
            return null;
        }

        return data.data;
    }

    /**
     * Get profile in context if exists
     * @param context_uuid {string} UUID of the context
     * @returns {Promise<*|null>} profile
     */
    async getProfile(context_uuid) {
        const response = await this.get('/user/profile', {'context_uuid': context_uuid});

        const data = await response.json();

        if(data.error) {
            alert(data.message)
            return null;
        }

        return data.data;
    }

    /**
     * Get whitelisted token balances in context
     * @param context_uuid {string} UUID of the context
     * @returns {Promise<Array<{token_id: number, balance: number}>|null>} token balances
     */
    async getBalances(context_uuid) {
        const response = await this.get('/user/balances', {'context_uuid': context_uuid});

        const data = await response.json();

        if(data.error) {
            alert(data.message)
            return null;
        }

        return data.data;
    }
}